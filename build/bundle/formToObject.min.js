(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["formToObject"] = factory();
	else
		root["formToObject"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/FormToObject.ts":
/*!*****************************!*\
  !*** ./src/FormToObject.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormToObject = void 0;
const dom_1 = __webpack_require__(/*! ./dom */ "./src/dom.ts");
const utils_1 = __webpack_require__(/*! ./utils */ "./src/utils.ts");
class FormToObject {
    constructor(selector, options) {
        this.formSelector = '';
        this.$form = null;
        this.$formElements = [];
        // Experimental. Don't rely on them yet.
        this.settings = {
            includeEmptyValuedElements: false,
            w3cSuccessfulControlsOnly: false,
            debug: true
        };
        // Assign the current form reference.
        if (!selector) {
            throw new Error('No selector was passed.');
        }
        // The form reference is always the first parameter of the method.
        // Eg: formToObject('myForm')
        this.formSelector = selector;
        // Override current settings.
        // Eg. formToObject('myForm', {mySetting: true})
        if (typeof options !== 'undefined' && (0, utils_1.getObjLength)(options) > 0) {
            (0, utils_1.extend)(this.settings, options);
        }
        if (!this.initForm()) {
            throw new Error('The <form> DOM element could not be found.');
        }
        if (!this.initFormElements()) {
            throw new Error('No <form> DOM elements were found. Form is empty.');
        }
    }
    /**
     * An HTML <form> can be initialized with a string DOM selector e.g. '.myForm'
     * or a DOM object reference.
     */
    initForm() {
        if (typeof this.formSelector === 'string') {
            this.$form = document.getElementById(this.formSelector);
            return (0, dom_1.isDomElementNode)(this.$form);
        }
        else if ((0, dom_1.isDomElementNode)(this.formSelector)) { // @todo: Should I check for DOM.nodeType?
            this.$form = this.formSelector;
            return true;
        }
        return false;
    }
    // Set the elements we need to parse.
    initFormElements() {
        var _a;
        this.$formElements = [...(_a = this.$form) === null || _a === void 0 ? void 0 : _a.querySelectorAll('input, textarea, select')];
        return this.$formElements.length > 0;
    }
    convertToObj() {
        let i = 0;
        let objKeyNames;
        let $domNode;
        let domNodeValue;
        const result = Object.create(null);
        for (i = 0; i < this.$formElements.length; i++) {
            $domNode = this.$formElements[i];
            // Skip the element if the 'name' attribute is empty.
            // Skip the 'disabled' elements.
            // Skip the non-selected radio elements.
            if (!$domNode.name ||
                $domNode.name === '' ||
                $domNode.disabled ||
                ((0, dom_1.isRadio)($domNode) && !(0, dom_1.isChecked)($domNode))) {
                continue;
            }
            // Get the final processed domNode value.
            domNodeValue = this.getNodeValues($domNode);
            // Exclude empty valued nodes if the settings allow it.
            if (domNodeValue === false && !this.settings.includeEmptyValuedElements) {
                continue;
            }
            // Extract all possible keys
            // E.g. name="firstName", name="settings[a][b]", name="settings[0][a]"
            objKeyNames = $domNode.name.match(FormToObject.keyRegex);
            if (objKeyNames && objKeyNames.length === 1) {
                this.processSingleLevelNode($domNode, objKeyNames, (domNodeValue ? domNodeValue : ''), result);
            }
            if (objKeyNames && objKeyNames.length > 1) {
                this.processMultiLevelNode($domNode, objKeyNames, (domNodeValue ? domNodeValue : ''), result);
            }
        }
        // Check the length of the result.
        const resultLength = (0, utils_1.getObjLength)(result);
        return resultLength > 0 ? result : false;
    }
    getNodeValues($domNode) {
        var _a;
        // We're only interested in the radio that is checked.
        if ((0, dom_1.isRadio)($domNode)) {
            return (0, dom_1.isChecked)($domNode) ? $domNode.value : false;
        }
        // We're only interested in the checkbox that is checked.
        if ((0, dom_1.isCheckbox)($domNode)) {
            return (0, dom_1.isChecked)($domNode) ? $domNode.value : false;
        }
        // File inputs are a special case.
        // We have to grab the .files property of the input, which is a FileList.
        if ((0, dom_1.isFileField)($domNode)) {
            // Ignore input file fields if the form is not encoded properly.
            if ((0, dom_1.isUploadForm)(this.$form)) {
                // HTML5 compatible browser.
                if ((0, dom_1.isFileList)($domNode) && ((_a = $domNode === null || $domNode === void 0 ? void 0 : $domNode.files) === null || _a === void 0 ? void 0 : _a.length)) {
                    return $domNode.files;
                }
                else {
                    return ($domNode.value && $domNode.value !== '' ?
                        $domNode.value :
                        false);
                }
            }
            else {
                return false;
            }
        }
        // We're only interested in textarea fields that have values.
        if ((0, dom_1.isTextarea)($domNode)) {
            return ($domNode.value && $domNode.value !== '' ?
                $domNode.value :
                false);
        }
        if ((0, dom_1.isSelectSimple)($domNode)) {
            if ($domNode.value && $domNode.value !== '') {
                return $domNode.value;
            }
            else if ($domNode.options &&
                $domNode.options.length &&
                $domNode.options[0].value !== '') {
                return $domNode.options[0].value;
            }
            else {
                return false;
            }
        }
        // We're only interested in multiple selects that have at least one option selected.
        if ((0, dom_1.isSelectMultiple)($domNode)) {
            if ($domNode.options && $domNode.options.length > 0) {
                const values = [];
                (0, utils_1.forEach)($domNode.options, function ($option) {
                    if ($option.selected) {
                        values.push($option.value);
                    }
                });
                if (this.settings.includeEmptyValuedElements) {
                    return values;
                }
                else {
                    return (values.length ? values : false);
                }
            }
            else {
                return false;
            }
        }
        // We're only interested if the button is type="submit"
        if ((0, dom_1.isSubmitButton)($domNode)) {
            if ($domNode.value && $domNode.value !== '') {
                return $domNode.value;
            }
            if ($domNode.innerText && $domNode.innerText !== '') {
                return $domNode.innerText;
            }
            return false;
        }
        // Fallback or other non-special fields.
        if (typeof $domNode.value !== 'undefined') {
            if (this.settings.includeEmptyValuedElements) {
                return $domNode.value;
            }
            else {
                return ($domNode.value !== '' ? $domNode.value : false);
            }
        }
        else {
            return false;
        }
    }
    processSingleLevelNode($domNode, arr, domNodeValue, result) {
        // Get the last remaining key.
        const key = arr[0];
        // We're only interested in the radio that is checked.
        if ((0, dom_1.isRadio)($domNode)) {
            if (domNodeValue !== false) {
                result[key] = domNodeValue;
                return domNodeValue;
            }
            else {
                return;
            }
        }
        // Checkboxes are a special case.
        // We have to grab each checked values
        // and put them into an array.
        if ((0, dom_1.isCheckbox)($domNode)) {
            if (domNodeValue !== false) {
                if (this.formElementHasSiblings($domNode)) {
                    if (!result[key]) {
                        result[key] = [];
                    }
                    return result[key].push(domNodeValue);
                }
                else {
                    result[key] = domNodeValue;
                }
            }
            else {
                return;
            }
        }
        // Multiple select is a special case.
        // We have to grab each selected option and put them into an array.
        if ((0, dom_1.isSelectMultiple)($domNode)) {
            if (domNodeValue !== false) {
                result[key] = domNodeValue;
            }
            else {
                return;
            }
        }
        // Fallback or other cases that don't
        // need special treatment of the value.
        result[key] = domNodeValue;
        return domNodeValue;
    }
    processMultiLevelNode($domNode, arr, value, result) {
        const keyName = arr[0];
        if (arr.length > 1) {
            if (keyName === '[]') {
                //result.push({});
                result[(0, utils_1.getNextIntegerKey)(result)] = Object.create(null);
                return this.processMultiLevelNode($domNode, arr.splice(1, arr.length), value, result[(0, utils_1.getLastIntegerKey)(result)]);
            }
            else {
                if (result[keyName] && (0, utils_1.getObjLength)(result[keyName]) > 0) {
                    //result[keyName].push(null);
                    return this.processMultiLevelNode($domNode, arr.splice(1, arr.length), value, result[keyName]);
                }
                else {
                    result[keyName] = Object.create(null);
                }
                return this.processMultiLevelNode($domNode, arr.splice(1, arr.length), value, result[keyName]);
            }
        }
        // Last key, attach the original value.
        if (arr.length === 1) {
            if (keyName === '[]') {
                //result.push(value);
                result[(0, utils_1.getNextIntegerKey)(result)] = value;
                return result;
            }
            else {
                this.processSingleLevelNode($domNode, arr, value, result);
                //  result[keyName] = value;
                return result;
            }
        }
    }
    formElementHasSiblings($domNode) {
        const name = $domNode.name;
        return Array.prototype.filter.call(this.$formElements, (input) => { return input.name === name; }).length > 1;
    }
}
exports.FormToObject = FormToObject;
// Currently matching only fields like 'fieldName[...] or fieldName[]'.
FormToObject.keyRegex = /[^[\]]+|\[]/g;


/***/ }),

/***/ "./src/dom.ts":
/*!********************!*\
  !*** ./src/dom.ts ***!
  \********************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isFileList = exports.isChecked = exports.isSubmitButton = exports.isSelectMultiple = exports.isSelectSimple = exports.isTextarea = exports.isFileField = exports.isCheckbox = exports.isRadio = exports.isUploadForm = exports.isDomElementNode = void 0;
/**
 * Check to see if the object is an HTML node.
 *
 * @param {HTMLFormElement | HTMLElement} node
 * @returns {boolean}
 */
function isDomElementNode(node) {
    return (Boolean(node) && typeof node === 'object' && 'nodeType' in node && node.nodeType === 1);
}
exports.isDomElementNode = isDomElementNode;
function isUploadForm($form) {
    return Boolean($form.enctype && $form.enctype === 'multipart/form-data');
}
exports.isUploadForm = isUploadForm;
function isRadio($domNode) {
    return $domNode.nodeName === 'INPUT' && $domNode.type === 'radio';
}
exports.isRadio = isRadio;
function isCheckbox($domNode) {
    return $domNode.nodeName === 'INPUT' && $domNode.type === 'checkbox';
}
exports.isCheckbox = isCheckbox;
function isFileField($domNode) {
    return $domNode.nodeName === 'INPUT' && $domNode.type === 'file';
}
exports.isFileField = isFileField;
function isTextarea($domNode) {
    return $domNode.nodeName === 'TEXTAREA';
}
exports.isTextarea = isTextarea;
function isSelectSimple($domNode) {
    return $domNode.nodeName === 'SELECT' && $domNode.type === 'select-one';
}
exports.isSelectSimple = isSelectSimple;
function isSelectMultiple($domNode) {
    return $domNode.nodeName === 'SELECT' && $domNode.type === 'select-multiple';
}
exports.isSelectMultiple = isSelectMultiple;
function isSubmitButton($domNode) {
    return $domNode.nodeName === 'BUTTON' && $domNode.type === 'submit';
}
exports.isSubmitButton = isSubmitButton;
function isChecked($domNode) {
    return $domNode.checked;
}
exports.isChecked = isChecked;
//function isMultiple($domNode){
//  return ($domNode.multiple ? true : false);
//}
function isFileList($domNode) {
    return (window.FileList && ($domNode.files instanceof window.FileList));
}
exports.isFileList = isFileList;


/***/ }),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.forEach = exports.extend = exports.getObjLength = exports.getNextIntegerKey = exports.getLastIntegerKey = exports.checkForLastNumericKey = void 0;
/**
 * Check for last numeric key.
 */
function checkForLastNumericKey(o) {
    if (!o || typeof o !== 'object') {
        return;
    }
    return Object.keys(o).filter(function (elem) {
        return !isNaN(parseInt(elem, 10));
    }).splice(-1)[0];
}
exports.checkForLastNumericKey = checkForLastNumericKey;
/**
 * Get last numeric key from an object.
 * @param o object
 * @return int
 */
function getLastIntegerKey(o) {
    const lastKeyIndex = checkForLastNumericKey(o);
    if (typeof lastKeyIndex === 'string') {
        return parseInt(lastKeyIndex, 10);
    }
    else {
        return 0;
    }
}
exports.getLastIntegerKey = getLastIntegerKey;
/**
 * Get the next numeric key (like the index from a PHP array)
 * @param o object
 * @return int
 */
function getNextIntegerKey(o) {
    const lastKeyIndex = checkForLastNumericKey(o);
    if (typeof lastKeyIndex === 'string') {
        return parseInt(lastKeyIndex, 10) + 1;
    }
    else {
        return 0;
    }
}
exports.getNextIntegerKey = getNextIntegerKey;
/**
 * Get the real number of properties from an object.
 *
 * @param {object} o
 * @returns {number}
 */
function getObjLength(o) {
    if (typeof o !== 'object' || o === null) {
        return 0;
    }
    let l = 0;
    let k;
    if (typeof Object.keys === 'function') {
        l = Object.keys(o).length;
    }
    else {
        for (k in o) {
            if (Object.prototype.hasOwnProperty.call(o, k)) {
                l++;
            }
        }
    }
    return l;
}
exports.getObjLength = getObjLength;
/**
 * Simple extend of own properties.
 * Needed for our settings.
 *
 * @param {IFormToObjectOptions} settings
 * @param  {IFormToObjectOptions} source The object with new properties that we want to add the destination.
 * @return {IFormToObjectOptions}
 */
function extend(settings, source) {
    let i;
    for (i in source) {
        if (Object.prototype.hasOwnProperty.call(source, i)) {
            settings[i] = source[i];
        }
    }
    return settings;
}
exports.extend = extend;
// Iteration through collections. Compatible with IE.
function forEach(arr, callback) {
    return Array.prototype.forEach.call(arr, callback);
}
exports.forEach = forEach;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
var exports = __webpack_exports__;
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/

Object.defineProperty(exports, "__esModule", ({ value: true }));
const FormToObject_1 = __webpack_require__(/*! ./FormToObject */ "./src/FormToObject.ts");
function formToObject(selector, options) {
    try {
        const instance = new FormToObject_1.FormToObject(selector, options);
        return instance.convertToObj();
    }
    catch (e) {
        console.log('formToObject ERROR:', e.message);
    }
}
exports["default"] = formToObject;

})();

__webpack_exports__ = __webpack_exports__["default"];
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=formToObject.min.js.map